# Лабораторна робота: Реалізація Regex Engine з використанням скінченних автоматів (патерн State)

## Опис програми

Ця програма реалізує спрощений механізм обробки регулярних виразів (Regex) за допомогою скінченних автоматів та патерну "Стан" (State). Вона дозволяє компілювати регулярний вираз у внутрішнє представлення та перевіряти, чи відповідає заданий рядок цьому виразу.

### Основні можливості програми:

1. **Парсинг регулярного виразу**:
   - Програма аналізує вхідний регулярний вираз і перетворює його на структурований список токенів.
   - Підтримуються такі елементи регулярних виразів:
     - Літери англійського алфавіту (верхній та нижній регістр) і цифри.
     - Символ `.` (крапка) — відповідає будь-якому одному символу.
     - Оператори `*` (зірочка) та `+` (плюс):
       - `*` — відповідає нулю або більше повторень попереднього символу.
       - `+` — відповідає одному або більше повторень попереднього символу.
     - Класи символів (наприклад, `[a-z]`, `[0-9]`, `[^a-c]`):
       - `[abc]` — відповідає одному з символів `a`, `b` або `c`.
       - `[a-z]` — відповідає будь-якій малій літері від `a` до `z`.
       - `[^abc]` — відповідає будь-якому символу, крім `a`, `b` або `c`.

2. **Перевірка відповідності рядка**:
   - Програма дозволяє перевірити, чи відповідає заданий рядок регулярному виразу.
   - Використовується алгоритм зворотного відстеження (backtracking) для перевірки відповідності.

3. **Обробка помилок**:
   - Генерується `ValueError` для некоректних регулярних виразів (наприклад, порожній вираз або вираз, що починається з `*` чи `+`).

---

## Як працює програма

### 1. Парсинг регулярного виразу

Метод `_parse_pattern` класу `RegexFSM` розбирає регулярний вираз на список токенів. Кожен токен — це кортеж, що складається з типу токена та його значення. Наприклад:
- `('char', 'a')` — літеральний символ `a`.
- `('star', 'b')` — символ `b`, повторений нуль або більше разів.
- `('class', 'a-z')` — клас символів `[a-z]`.

### 2. Перевірка відповідності рядка

Метод `check_string` використовує рекурсивний метод `_match`, який:
- Проходить по списку токенів і символах рядка.
- Для кожного токена перевіряє, чи відповідає поточний символ рядка.
- Для операторів `*` та `+` виконує рекурсивні виклики для обробки повторень.

---

## Структура програми

### Класи станів (State Pattern)

Програма використовує патерн "Стан" для представлення різних елементів регулярного виразу. Кожен стан реалізує метод `check_self`, який перевіряє, чи відповідає символ певному стану.

- **`State`**: Абстрактний базовий клас для всіх станів.
- **`StartState`**: Початковий стан (не відповідає жодному символу).
- **`TerminationState`**: Кінцевий стан (не приймає жодних символів).
- **`DotState`**: Відповідає символу `.` (будь-який символ).
- **`AsciiState`**: Відповідає конкретному літеральному символу.
- **`CharacterClassState`**: Відповідає класу символів (наприклад, `[a-z]`).
- **`StarState`**: Відповідає оператору `*` (нуль або більше повторень).
- **`PlusState`**: Відповідає оператору `+` (один або більше повторень).

### Клас `RegexFSM`

Цей клас відповідає за:
1. Парсинг регулярного виразу (`_parse_pattern`).
2. Перевірку відповідності рядка регулярному виразу (`check_string` та `_match`).

---

## Результати

Нижче наведено результати роботи програми з різними регулярними виразами та вхідними рядками:

### Приклад 1: `a*4.+hi`
```
Pattern: a*4.+hi
'aaaaaa4uhi': True
'4uhi': True
'meow': False
```

### Приклад 2: `[0-9]+`
```
Pattern: [0-9]+
'123': True
'abc': False
'123abc': False
```

### Приклад 3: `[a-z][0-9]`
```
Pattern: [a-z][0-9]
'a5': True
'z0': True
'A5': False
'a': False
```

### Приклад 4: `[^a-z]+`
```
Pattern: [^a-z]+
'123': True
'ABC': True
'abc': False
```

### Приклад 5: `.*@[a-z]+\.[a-z]+`
```
Pattern: .*@[a-z]+\.[a-z]+
'user@example.com': True
'@domain.com': True
'invalid': False
```

### Приклад 6: `[a-zA-Z]+[0-9]*`
```
Pattern: [a-zA-Z]+[0-9]*
'abc': True
'ABC123': True
'123abc': False
```

### Приклад 7: `a[bc]*d`
```
Pattern: a[bc]*d
'ad': True
'abcbcd': True
'abde': False
```

---

## Висновки

Ця програма демонструє, як можна реалізувати базовий функціонал регулярних виразів за допомогою скінченних автоматів та патерну "Стан". Вона підтримує основні елементи регулярних виразів, включаючи класи символів, оператори `*` та `+`. Реалізація парсера та алгоритму зворотного відстеження дозволила спростити обробку складних конструкцій регулярних виразів.

